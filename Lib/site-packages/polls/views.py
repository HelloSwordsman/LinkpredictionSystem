from django.shortcuts import render

# Create your views here.
# Each view is represented by a simple Python function (or method, in the case of class-based views).
# Each view is responsible for doing one of two things: returning an HttpResponse object containing the content for the requested page, 
# or raising an exception such as Http404.
from django.http import HttpResponse,HttpResponseRedirect
from .models import Question,Choice
from django.template import loader
from django.http import Http404
from django.shortcuts import render,get_object_or_404
from django.urls import reverse
from django.views import generic

# request is an HttpRequest object. For more on HttpRequest objects, see the request and response documentation.
# https://docs.djangoproject.com/en/2.1/ref/request-response/
def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    # 选择模板
    # 按照惯例，Djangotemplates会在每个 INSTALLED_APPS 中查找“templates”子目录。因此，您可以在Django中将此模板简单地称为polls/index.html
    template = loader.get_template('polls/index.html')
    # 指出渲染对象，index.html 中有 {% if latest_question_list %}，会选择到 context 中 latest_question_list 对应的值
    context = {
        "latest_question_list":latest_question_list,
    }
    # output = ','.join([q.question_text for q in latest_question_list])
    # 选择的模板调用 render 函数开始渲染，并返回 HTTPResponse 对象到浏览器显示出来
    return HttpResponse(template.render(context,request))

# 简略版，不需要导入 HttpResponse 和 loader
# 同样返回 HttpResponse 对象，render 的第一个参数是 request 第二个参数是 templates 的名称，第三个参数是可选的字典
# from django.shortcuts import render
# from .models import Question
# def index(request):
#     latest_question_list = Question.objects.order_by('-pub_date')[:5]
#     context = {'latest_question_list': latest_question_list}
#     return render(request, 'polls/index.html', context)


# detail(request=<HttpRequest object>, question_id=34)
def detail(request,question_id):
    try:
        question = Question.objects.get(pk=question_id)
    except Question.DoesNotExist as DNE:
        raise Http404("Question does not exist!")
    return render(request,'polls/detail.html',{'question':question})

# 简略版,代替使用 get 函数然后抛出 Http404 异常
# get_object_or_404() 使用 Django model 作为第一个参数，以及一个关键字参数的任意数字，他会传给 model 管理器的 get 函数
# 如果对象不存在就抛出 Http404 异常，不必使用 raise 抛出异常
# from django.shortcuts import get_object_or_404, render
# from .models import Question
# # ...
# def detail(request, question_id):
#     question = get_object_or_404(Question, pk=question_id)
#     return render(request, 'polls/detail.html', {'question': question})

def results(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, 'polls/results.html', {'question': question})

# def vote(request,question_id):
#     return HttpResponse("You are voting on question %s." % question_id)
def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        # It first gets the selected_choice object from the database, then computes the new value of votes, and then saves it back to the database.
        # request.POST 是一个类字典的对象，让你能够通过键名得到对应的上传的值
        # 也就说，选择了某个 choice 然后上传后，就会将 name 和 value 以字典的形式发送出去，然后通过 request.POST[name] 接收到 value
        selected_choice = question.choice_set.get(pk=request.POST['choice'])
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
        return render(request, 'polls/detail.html', {
            'question': question,
            'error_message': "You didn't select a choice.",
        })
    else:
        selected_choice.votes += 1
        selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.
        # HttpResponseRedirect 接受一个参数，那就是将要重定向到的 url(reverse就是反向解析得到 url)
        # reverse函数避免在view中对url硬编码,给他提供想要控制的视图名称以及url pattern中指向这个视图的变量部分就可以了
        # 这个例子中将会得到这个字符串(string):'/polls/3/results/'
        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))


# 使用 generic
# class IndexView(generic.ListView):
#     template_name = 'polls/index.html'
#     context_object_name = 'latest_question_list'

#     def get_queryset(self):
#         """Return the last five published questions."""
#         return Question.objects.order_by('-pub_date')[:5]


# class DetailView(generic.DetailView):
#     model = Question
#     template_name = 'polls/detail.html'


# class ResultsView(generic.DetailView):
#     model = Question
      # 默认情况下 DetailView generic view 会使用 <app name>/<model name>_detail.html 模板，这里指定template_name是要使用我们自己的模板
#     template_name = 'polls/results.html'